package com.codi.mc.sender.api.service;

/**
 * Created by Shangdu Lin on 2017/3/2 13:38.
 */
public interface SMSMessageService {

    /**
     * 单进程单线程发送短信
     * <p>
     * 遍历短信表，找出所有未发送的短信，通过短信渠道发送短信，此方法遇到不合法的短信将被忽略，继续发送其他短信，但会写入错误日志
     * 先从短信模板中获取短信渠道,如果短信模板中未配置短信渠道，则从应用配置中获取短信渠道
     */
    void sendSMS();

    /**
     * 分布式并发发送短信
     * <p>
     * 此方法实现的redis分布式锁的缺陷在锁可能会没及时被删除或不会被删除或过期被删除但错误，可能引起的后果:
     * 1. send(message)调用成功但发送失败，当调用jedis.del(lockKey)服务器宕机，导致删除失败，且锁还未过期， 如果此时通过更新数据库此短信记录状态为未发送，以此来重发短信，
     * 会发现在同一个messageId的短信记录不能被及时重复发送，锁过期后才会被发送，所以用此方法时当要重复发送一条短信时，为避免发送没有及时发送出去的情况，需要重新插入一条一样的短信记录
     * <p>
     * 2. send(message)调用成功但发送失败，当调用jedis.del(lockKey)服务器宕机，导致删除失败，此锁会被一直保存在redis，
     * 因为发送失败的短信不会被取出来处理，所有就算锁过期也不会被删除，但如果不重发此短信，此种情况对业务没影响
     * <p>
     * 3. send(message)执行期间服务器挂了，此时短信还未被发送出去，锁未被删除且未过期，导致短信未被及时发送出去，只有锁过期后才会被发送出去
     * <p>
     * 4. 当过了过期时间（现在是1分钟），但短信还没发送出去，锁可能会被其他线程删除，会导致短信会被重复发送，1分钟的过期时间理论上不会出现此问题
     *
     * 为什么要删除锁呢？是否可以每次发完短信不删除锁？
     * 不删除锁方案的缺陷：
     * 1. 当获取锁成功，但send(message)调用失败（服务器升级/宕机），短信未发送出去，还是属于未发送状态，则此短信永远不会被发送
     * 2. 同一短信不能重复发送，必须新建一条短信来发送
     */
    void redisLockSendSMS();

    /**
     * 分布式并发发送短信，不删除锁
     * 缺陷：
     * 1. 当jedis.setnx获取锁成功，但send(message)调用失败（服务器升级/宕机），短信未发送出去，还是属于未发送状态，则此短信永远不会被发送
     * 2. 同一短信不能重复发送，必须新建一条短信来发送
     */
    void redisLockNoDeleteSendSMS();
}
